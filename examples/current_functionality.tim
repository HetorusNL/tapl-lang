println("basic print functionality")
println(1100 + 150 * 2 + 37 - 100)
println(1 * 2 + 3 / (4 + true))
println(1 + 1 - 1)

println("\nvariables and printing of variables")
u16 bla
println(bla)  // TODO: fix that I'm not 0 (initial value of type)
u16 bla2 = 1337
println(bla2)
u8 value = 0
value = 1
print("value of value after assignment: {value}")

println("\ntesting types")
u1 _u1 = 1
u8 _u8 = 12
u16 _u16 = 1234
u32 _u32 = 123456
u64 _u64 = 12345678
s8 _s8 = -12
s16 _s16 = -1234
s32 _s32 = 123456
s64 _s64 = -12345678
f32 _f32 = -12345678
f64 _f64 = -12345678

println("\nprinting types")
println(_u1)
println(_u8)
println(_u16)
println(_u32)
println(_u64)
println(_s8)
println(_s16)
println(_s32)
println(_s64)
println(_f32)
println(_f64)

println("\nboolean expressions")
println(1 == 1)
println(1 == 2)
println(2 > 1)
println(1 > 2)
println(2 >= 1)
println(1 >= 1)
println(1 >= 2)
println(1 < 2)
println(2 < 1)
println(1 <= 2)
println(1 <= 1)
println(2 <= 1)
println(1337 != 1338)
println(1337 != 1337)

println("\nparse an if-statement")
if 1337:
    println(1337)
else if 1338:
    println(1338)
else:
    println(0)

println("\ntesting pre and post increment/decrement")
u8 index = 0
println(index++)
println(index++)
u8 other_index = 0
println(++other_index)
println(--other_index)

println("\nparsing a for-loop statement")
for u8 i = 0; i < 10; i++:
    i++
    println(i)
println("also test printing everything on a single line")
for u8 i = 0; i < 10; i++:
    print(i)
println("")  // TODO: fix that I need an empty string here :D
println("and parsing a while-loop statement")
u8 idx = 0
while idx++ < 10:
    idx++
    println(idx)

println("\nparsing function statements")
u8 func1(u8 argument):
    println(argument)
    u8 local = 1
    local++
    println(local)
    return argument + local
u8 func2():  // u8 as we don't support pointers (yet) :s
    println(1337)
    return null
void func3(u8 a, u8 b, u8 c):
    println(a + b + c)
    return
println("and call the functions")
println("func1:")
u8 ret1 = func1(10)
println("return1: {ret1}")
println("func2:")
u8 ret2 = func2()
println("return2: {ret2}")
println("func3:")
func3(1, 2, 3)
println("func3 returns void")

println("\ntype-cast a value around")
u8 small = 123
println(small)
u16 big = (u16)small + 1337 // this is gonna be big
println(big)
u8 small_again = (u8)big // this is not able to hold the big number
println(small_again)

println("\ndo we support 0xe stuff??")
println("println(0xe+1): {0xe+1}")
println("yes we do!")

// example classes

class ExampleClass:
    // first we define the variables that the class contain (like entries of a struct)
    u32 variable1
    u8 variable2
    bool _is_true

    // then we have functions of the class (and constructor/destructor if present)

    ExampleClass(u32 constructor_value):
        // initialization happens here, the constructor (if it is present)
        u8 iets = 0
        this.variable1 = constructor_value
        iets = 1
        iets = 2
        this.variable2 = 10
        this._is_true = false

    ~ExampleClass():
        // destruction can happen here

    u32 get_value():
        u32 offset = 5
        return this.variable1 + (u32)this.variable2 + offset

    bool is_true():
        return this._is_true

    u32 result():
        if this.is_true():
            return this.get_value()
        else:
            return 0

    u32 add(u32 value):
        return this.get_value() + value

ExampleClass instance
println("result(): {instance.result()}")
println("add(1337): {instance.add(1337)}")

/*
// single class function
ExampleClass instance;
instance.func()
-> ExampleClass_func(&instance);

// multiple class function
class C1 {
    void func() {
        //
    }
}

class C2 {
    C1 c1;
    C2(C1 c1) {
        this.c1 = c1;
    }
}

C1 c1;
C2 c2 = C2(c1)
c2.c1.func()
-> C1_func(&c2.c1);
*/

println("example usage of 'list' collection")

println("create an instance of a list, which has a size of 0")
list[u32] some_list

println("some functions to be called on the list")
println("\nreturns the size, should be initialized as 0: {some_list.size()}")
some_list.add(1337)
println("\nadds an element, 1, to the list, size: {some_list.size()}")
println("\ngets the 0th element (or 0/crash when not there): {some_list.get(0)}")
println("\nremoves the 0th element, return true on success, false/crash on failure: {some_list.del(0)}")
println("\ninserts 10 at location 0, return true on success, false/crash on failure: {some_list.insert(0, 10)}")
println("\nsize of the list now: {some_list.size()}")
println("\ngets the 0th element (or 0/crash when not there) {some_list.get(0)}")
list[f64] doublee
list[u1] boool
list[char] charr
charr.add(0)
charr.add(1)
println(charr.size())
println(charr.get(0))
println(charr.get(1))
println("value of charr.get(1): {charr.get(1)}, woohoo")

// example program using buitin variables

u32 variable = 1337
println("\nvalue of variable is: {variable}")

s32 negative_variable = -1 * 1337
println("the negative value is: {negative_variable}")

println("calculation can be done in a string! 1 + 1 = {1 + 1}")

println("\nwe also support characters, like char c = 'c'")
char c = 'c'
println("the character is printed as: {c} (with numeric value: {(u8)c})")

println("")
if 1 == 1 && 2 == 2:
    println("we support '&&'!")
if 1 == 2 || 2 == 2:
    println("we also support '||'!")

// test the list del and insert functionality
println("\ntesting list del and insert functionality")
list[u8] test_list
for u8 value = 0; value < 10; value++:
    // add values 0-9 to the list
    test_list.add(value)

for u8 value = 0; value < 10; value++:
    // remove the values from the positions
    print("del ")
    test_list.del(value)
    for u64 index = 0; index < test_list.size(); index++:
        print("{test_list.get(index)} ")
    println("")
    print("ins ")
    // then insert them again
    test_list.insert(value, value)
    for u64 index = 0; index < test_list.size(); index++:
        print("{test_list.get(index)} ")
    println("")

// test the list set functionality
println("\ntesting list set functionality")
list[u8] set_test_list
for u8 value = 0; value < 10; value ++:
    // add values 0-9 to the list
    set_test_list.add(value)
for u64 index = 0; index < set_test_list.size(); index++:
    print("{set_test_list.get(index)} ")
println("")
println("setting every odd index values to the inverse + 1 (10 - index)")
for u8 index = 0; index < 10; index = index + 2:
    set_test_list.set(index, 10 - index)
for u64 index = 0; index < set_test_list.size(); index++:
    print("{set_test_list.get(index)} ")
println("")

println("\ncheck that we can read a file, e.g. README.md")
// create a nice buffer to hold our chars of the file
list[char] buffer

// call the stdlib function to read a file into a buffer
read_file("README.md", buffer)

// done! let's see how many items there are
println("success, number of chars in the file/buffer: {buffer.size()}")

list[u8] func_list
void add_list2(list[u8] input_list, u8 value):
    input_list.add(value * 2)
void add_list1(list[u8] input_list, u8 value):
    input_list.add(value)
    add_list2(input_list, value)

// we should be able to (nestedly) call functions with lists
add_list1(func_list, 10)

for u64 index = 0; index < func_list.size(); index++:
    println("index: {index}, value: {func_list.get(index)}")

// we also support for-loops with a statement in the loop position
println("counting from 0 to <9 in steps of 3 in the form of 'index = index + 3'")
for u64 index = 0; index < 9; index = index + 3:
    println(index)
println("and shorthand using 'index += 3'")
for u64 index = 0; index < 9; index += 3:
    println(index)

// test the escape sequences for characters
char c1 = 'a'
char c2 = '\n'
char c3 = '\r'
char c4 = '\t'
char c5 = '\\'
char c6 = '\''
println("\ntesting parsing character escape sequences:")
println("we got these character values:")
println("'a' ->\n'{c1}'")
println("'\\n' ->\n'{c2}'")
println("'\\r' ->\n'{c3}'")
println("'\\t' ->\n'{c4}'")
println("'\\\\' ->\n'{c5}'")
println("'\\'' ->\n'{c6}'")

println("\nlet's print the content of README.md[:256] as '.' chars with newlines:")
u64 max_chars = buffer.size()
if max_chars > 256:
    max_chars = 256
for u64 index = 0; index < max_chars; index++:
    char c = buffer.get(index)
    if c == '\n':
        println("")
    else:
        print(".")
println("")

println("\nlet's test the double-character tokens ending in '='")
u64 test_value = 25
test_value += 10
println("25 += 10 = {test_value}")
test_value -= 10
println("35 -= 10 = {test_value}")
test_value *= 10
println("25 *= 10 = {test_value}")
test_value /= 10
println("250 /= 10 = {test_value}")

println("\nwe can now break from loops, no more infinite unbreakable loops!")
while true:
    println("inside the while true")
    break
println("outside the while true!")
for u64 outer = 0; outer < 10; outer++:
    println("inside the outer for loop")
    for u64 inner = 0; inner < 10; inner++:
        println("inside the inner for loop, we can use break")
        break
    for u64 inner = 0; inner < 2; inner++:
        println("inside another inner for loop, we can use continue (and go again)")
        if inner == 0:
            continue
        println("I'm not printed the first time...")
    println("even outside the inner for loops, we're allowed to use break")
    break
println("and we're done!")

println("\nwe can also break from nested loops!")
while true:
    for u64 inner = 0; inner < 10; inner++:
        println("inner loop (loops 10 times) but breaks from everything")
        breakall
    println("I'm not printed..")
for u64 outer = 0; outer < 10; outer++:
    while true:
        while true:
            println("also multiple breakall's can exist in a single function")
            breakall
    println("I'm not printed..")
println("cool stuff indeed")

println("\nwe can also use '=' inside a string interpolation as follows:")
u64 some_value = 1337
println("{some_value=}")
println("and a more complicated expression: {15*some_value+5/5=}")
